---
title: "testcase"
output: html_document
---
```{r}
library("devtools")
library(roxygen2)

setwd("../..")
document()
setwd("..")
install("SPM")
```

```{r}
library(tidyverse)
library(SPM)
```

```{r}
# read parameters
k0 <- 2
k1 <- 3
nlabel <- 3

d <- 20

N = 100

mu_Mu = 0
sigma2_Mu = 50
alpha_Lambda = 2
beta_Lambda=4

seed = 1

dg <- k0 + k1
K <- nlabel * k0 + k1
ntopic <- K

b <- 0.1
alpha <- c(3,3,3,2,2)

Ts <- T_generator(k0, k1, nlabel)

set.seed(seed)

a <- rexp(n = 1, rate = b)
rho <- gtools::rdirichlet(n = 1, alpha = alpha)

Lambda <- rgamma(n = ntopic * d, shape = alpha_Lambda, rate = beta_Lambda) %>%
  matrix(nrow = K)
Mu <- matrix(NA, nrow = K, ncol = d)
for (i in 1:K){
  for (j in 1:d){
    Mu[i, j] <- rnorm(1, mu_Mu, sqrt(sigma2_Mu / Lambda[i, j]))
  }
}
Tau <- Mu * Lambda

ntrace <- 2000
nchain <- 2
nskip <- 2
nsample <- 1000
```

#### simulating data

```{r}
dat <- document_generator_Normal(a, rho, Ts, Lambda, Tau, N, NULL, seed)
```

### SPM

#### training

```{r}
res <- SPM_training_Normal(dat[["X"]], dat[["Y"]], Ts, b, alpha, mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, ntrace, nchain, nskip)
```

#### test vi

```{r}
SPM_training_Normal <- function(X, Y, Ts, b, alpha, mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, VI = FALSE, ntrace = 1000, nchain = 2, nskip = 2){
  SPM_Normal_stancode <-"
  data {
    int<lower=0> dg;  // dim(membership)
    int<lower=0> N;  // size of training set
    int<lower=0> nlabel;
    int<lower=0> ntopic;
    int<lower=0> d; //dim of data
    
    matrix[N, d] X;
    int<lower=1> Y[N];         // label, start from 1 
    
    matrix[ntopic, dg] T[nlabel];
    
    real<lower=0> b;
    vector<lower=0>[dg] alpha;
    matrix[ntopic, d] mu_Mu;
    matrix[ntopic, d] sigma2_Mu;
    matrix[ntopic, d] alpha_Lambda;
    matrix[ntopic, d] beta_Lambda;
    
  }
  parameters {
    real<lower=0> a;
    simplex[dg] rho;
    
    simplex[dg] G[N];
    
    matrix[ntopic, d] Mu;
    matrix<lower=0>[ntopic, d] Lambda;

  }
  model{
    matrix[ntopic, d] Tau;
    vector[ntopic] U[N];
    row_vector[d] lambda_X[N];
    row_vector[d] tau_X[N];
    
    a ~ exponential(b);
    rho ~ dirichlet(alpha);

    // topics
    for (i in 1:ntopic){
      Lambda[i] ~ gamma(alpha_Lambda[i], beta_Lambda[i]);
      Mu[i] ~ normal(mu_Mu[i], sqrt(sigma2_Mu[i] ./ Lambda[i]));
      Tau[i] = Mu[i] .* Lambda[i];
    }
    
    for(i in 1:N){
      G[i] ~ dirichlet(a * rho);
      U[i] = T[Y[i]] * G[i];
      lambda_X[i] = U[i]' * Lambda;
      tau_X[i] = U[i]' * Tau;
      X[i] ~ normal(tau_X[i] ./ lambda_X[i], sqrt(1 ./ lambda_X[i]));
    }

  }
  "

  # calculate needed parameters (avoid too many inputs)
  N <- length(Y)
  nlabel <- dim(Ts)[1]
  dg <- dim(Ts)[3]
  ntopic <- dim(Ts)[2]
  d <- dim(X)[2]
  
  # we assume all hyperparameters for topics are matrices, if they are not, we will duplicate it to make a matrix
  # mu_Mu = SPM::trans_to_matrix(mu_Mu, ntopic, d)
  # sigma2_Mu = SPM::trans_to_matrix(sigma2_Mu, ntopic, d)
  # alpha_Lambda = SPM::trans_to_matrix(alpha_Lambda, ntopic, d)
  # beta_Lambda = SPM::trans_to_matrix(beta_Lambda, ntopic, d)
  mu_Mu = trans_to_matrix(mu_Mu, ntopic, d)
  sigma2_Mu = trans_to_matrix(sigma2_Mu, ntopic, d)
  alpha_Lambda = trans_to_matrix(alpha_Lambda, ntopic, d)
  beta_Lambda = trans_to_matrix(beta_Lambda, ntopic, d)
  
  # the data to fit
  dat_fit <- list(
    dg = dg,
    N = N,
    nlabel = nlabel,
    ntopic = ntopic,
    d = d,
    
    X = X,
    Y = Y,
    
    T = Ts,
    
    b = b, 
    alpha = alpha,
    mu_Mu = mu_Mu,
    sigma2_Mu = sigma2_Mu,
    alpha_Lambda = alpha_Lambda,
    beta_Lambda = beta_Lambda
  )
  
  # sampling
  if(VI){
    model <- rstan::stan_model(model_code = SPM_Normal_stancode)
    fit_train <-rstan::vb(model, data = dat_fit)
  }else{
    fit_train <-rstan::stan(model_code = SPM_Normal_stancode,
                            data = dat_fit,
                            chains = nchain,
                            iter = ntrace)
  }
  
  trace <- as.matrix(fit_train)
  
  # save results
  nsample <- dim(trace)[1]
  nsave <- nsample %/% nskip
  index_save <- (1:nsave) * nskip
  trace <- trace[index_save,]
  
  
  res <- list()
  
  paras <- c("G", "Lambda", "Mu")
  d1s <- c(N, K, K)
  d2s <- c(dg, d, d)
  for (i in 1:3){
    para <- paras[i]
    d1 <- d1s[i]
    d2 <- d2s[i]
    tem <- matrix(NA, nrow = d1, ncol = d2)
    for (i1 in 1:d1){
      for(i2 in 1:d2){
        varname <- sprintf("%s[%s,%s]", para, i1, i2)
        tem[i1, i2] <- mean(trace[, varname])
      }
    } 
    res[[para]] <- tem
  }
  
  res[["a"]] <- mean(trace[, "a"])
  
  tem <- rep(0, dg)
  for (i in 1:dg){
    varname <- sprintf("rho[%s]", i)
    tem[i] <- mean(trace[, varname])
  }
  res[["rho"]] <- tem
  
  res
}
res <- SPM_training_Normal(dat[["X"]], dat[["Y"]], Ts, b, alpha, mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, TRUE)
```

```{r}
library(rstan)
model <- stan_model(model_code = "
  data {
    int<lower=0> dg;  // dim(membership)
    int<lower=0> N;  // size of training set
    int<lower=0> nlabel;
    int<lower=0> ntopic;
    int<lower=0> d; //dim of data
    
    matrix[N, d] X;
    int<lower=1> Y[N];         // label, start from 1 
    
    matrix[ntopic, dg] T[nlabel];
    
    real<lower=0> b;
    vector<lower=0>[dg] alpha;
    matrix[ntopic, d] mu_Mu;
    matrix[ntopic, d] sigma2_Mu;
    matrix[ntopic, d] alpha_Lambda;
    matrix[ntopic, d] beta_Lambda;
    
  }
  parameters {
    real<lower=0> a;
    simplex[dg] rho;
    
    simplex[dg] G[N];
    
    matrix[ntopic, d] Mu;
    matrix<lower=0>[ntopic, d] Lambda;

  }
  model{
    matrix[ntopic, d] Tau;
    vector[ntopic] U[N];
    row_vector[d] lambda_X[N];
    row_vector[d] tau_X[N];
    
    a ~ exponential(b);
    rho ~ dirichlet(alpha);

    // topics
    for (i in 1:ntopic){
      Lambda[i] ~ gamma(alpha_Lambda[i], beta_Lambda[i]);
      Mu[i] ~ normal(mu_Mu[i], sqrt(sigma2_Mu[i] ./ Lambda[i]));
      Tau[i] = Mu[i] .* Lambda[i];
    }
    
    for(i in 1:N){
      G[i] ~ dirichlet(a * rho);
      U[i] = T[Y[i]] * G[i];
      lambda_X[i] = U[i]' * Lambda;
      tau_X[i] = U[i]' * Tau;
      X[i] ~ normal(tau_X[i] ./ lambda_X[i], sqrt(1 ./ lambda_X[i]));
    }

  }
  ")
dat_fit <- list(
    dg = dg,
    N = N,
    nlabel = nlabel,
    ntopic = ntopic,
    d = d,
    
    X = dat$X,
    Y = dat$Y,
    
    T = Ts,
    
    b = b, 
    alpha = alpha,
    mu_Mu = trans_to_matrix(mu_Mu, ntopic, d),
    sigma2_Mu = trans_to_matrix(sigma2_Mu, ntopic, d),
    alpha_Lambda = trans_to_matrix(alpha_Lambda, ntopic, d),
    beta_Lambda = trans_to_matrix(beta_Lambda, ntopic, d)
  )

res <- vb(model, data = dat_fit)
```
```{r}
res <- SPM_training_Norma_vsl(dat[["X"]], dat[["Y"]], Ts, b, alpha, mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, ntrace, nchain, nskip)
prediction <- SPM_predicting_Normal(dat[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
sum(prediction[["labels"]] == dat[["Y"]])
```


```{r}
SPM_training_Norma_vsl <- function(X, Y, Ts, b, alpha, mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, ntrace, nchain, nskip){
  SPM_Normal_stancode <-"
  data {
    int<lower=0> dg;  // dim(membership)
    int<lower=0> N;  // size of training set
    int<lower=0> nlabel;
    int<lower=0> ntopic;
    int<lower=0> d; //dim of data
    
    matrix[N, d] X;
    int<lower=1> Y[N];         // label, start from 1 
    
    matrix[ntopic, dg] T[nlabel];
    
    real<lower=0> b;
    vector<lower=0>[dg] alpha;
    matrix[ntopic, d] mu_Mu;
    matrix[ntopic, d] sigma2_Mu;
    matrix[ntopic, d] alpha_Lambda;
    matrix[ntopic, d] beta_Lambda;
    
  }
  parameters {
    real<lower=0> a;
    simplex[dg] rho;
    
    simplex[dg] G[N];
    
    matrix[ntopic, d] Mu;
    matrix<lower=0>[ntopic, d] Lambda;

  }
  model{
    matrix[ntopic, d] Tau;
    vector[ntopic] U[N];
    row_vector[d] lambda_X[N];
    row_vector[d] tau_X[N];
    
    a ~ exponential(b);
    rho ~ dirichlet(alpha);

    // topics
    for (i in 1:ntopic){
      Lambda[i] ~ gamma(alpha_Lambda[i], beta_Lambda[i]);
      Mu[i] ~ normal(mu_Mu[i], sqrt(sigma2_Mu[i] ./ Lambda[i]));
      Tau[i] = Mu[i] .* Lambda[i];
    }
    
    for(i in 1:N){
      G[i] ~ dirichlet(a * rho);
      U[i] = T[Y[i]] * G[i];
      lambda_X[i] = U[i]' * Lambda;
      tau_X[i] = U[i]' * Tau;
      X[i] ~ normal(tau_X[i] ./ lambda_X[i], sqrt(1 ./ lambda_X[i]));
    }

  }
  "

  # calculate needed parameters (avoid too many inputs)
  N <- length(Y)
  nlabel <- dim(Ts)[1]
  dg <- dim(Ts)[3]
  ntopic <- dim(Ts)[2]
  d <- dim(X)[2]
  
  # we assume all hyperparameters for topics are matrices, if they are not, we will duplicate it to make a matrix
  # mu_Mu = SPM::trans_to_matrix(mu_Mu, ntopic, d)
  # sigma2_Mu = SPM::trans_to_matrix(sigma2_Mu, ntopic, d)
  # alpha_Lambda = SPM::trans_to_matrix(alpha_Lambda, ntopic, d)
  # beta_Lambda = SPM::trans_to_matrix(beta_Lambda, ntopic, d)
  mu_Mu = trans_to_matrix(mu_Mu, ntopic, d)
  sigma2_Mu = trans_to_matrix(sigma2_Mu, ntopic, d)
  alpha_Lambda = trans_to_matrix(alpha_Lambda, ntopic, d)
  beta_Lambda = trans_to_matrix(beta_Lambda, ntopic, d)
  
  # the data to fit
  dat_fit <- list(
    dg = dg,
    N = N,
    nlabel = nlabel,
    ntopic = ntopic,
    d = d,
    
    X = X,
    Y = Y,
    
    T = Ts,
    
    b = b, 
    alpha = alpha,
    mu_Mu = mu_Mu,
    sigma2_Mu = sigma2_Mu,
    alpha_Lambda = alpha_Lambda,
    beta_Lambda = beta_Lambda
  )
  
  # sampling
  fit_train <-rstan::vb(model, data = dat_fit)
  
  trace <- as.matrix(fit_train)
  
  # save results
  nsample <- dim(trace)[1]
  nsave <- nsample %/% nskip
  index_save <- (1:nsave) * nskip
  trace <- trace[index_save,]
  
  
  res <- list()
  
  paras <- c("G", "Lambda", "Mu")
  d1s <- c(N, K, K)
  d2s <- c(dg, d, d)
  for (i in 1:3){
    para <- paras[i]
    d1 <- d1s[i]
    d2 <- d2s[i]
    tem <- matrix(NA, nrow = d1, ncol = d2)
    for (i1 in 1:d1){
      for(i2 in 1:d2){
        varname <- sprintf("%s[%s,%s]", para, i1, i2)
        tem[i1, i2] <- mean(trace[, varname])
      }
    } 
    res[[para]] <- tem
  }
  
  res[["a"]] <- mean(trace[, "a"])
  
  tem <- rep(0, dg)
  for (i in 1:dg){
    varname <- sprintf("rho[%s]", i)
    tem[i] <- mean(trace[, varname])
  }
  res[["rho"]] <- tem
  
  res
}

```


#### predicting

```{r}
prediction <- SPM_predicting_Normal(dat[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
sum(prediction[["labels"]] == dat[["Y"]])

prediction2 <- SPM_predicting_Normal(dat[["X"]], Lambda, Mu, a, rho, Ts, nsample, seed, w = NULL) # with true parameters
sum(prediction2[["labels"]] == dat[["Y"]])
```

#### estimating memberships

```{r}
m1 <- SPM_membership_Normal(dat[["X"]], prediction[["labels"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts,  2000, 2, nskip, seed)
#m2 <- SPM_membership_Normal(dat[["X"]], dat[["Y"]], Lambda, Mu, a, as.vector(rho), Ts, 2000, 1, nskip, seed)
```

```{r}
corrplot::corrplot(cor(t(U(dat[["G"]], dat[["Y"]], Ts))))
corrplot::corrplot(cor(t(dat[["X"]])))
corrplot::corrplot(cor(t(U(m1, prediction[['labels']], Ts))))
# corrplot::corrplot(cor(t(U(m2, prediction[['labels']], Ts))))
```

```{r}
save.image("./testcase.Rdata")
```


### BPM
```{r}
res_BPM <- BPM_training_Normal(dat[['X']], b, rep(1, ntopic), mu_Mu, sigma2_Mu, alpha_Lambda, beta_Lambda, ntopic, ntrace, nchain, nskip)
```

```{r}
corrplot::corrplot(cor(t(U(dat[["G"]], dat[["Y"]], Ts))))
corrplot::corrplot(cor(t(dat[["X"]])))
corrplot::corrplot(cor(t(U(m1, prediction[['labels']], Ts)))) # spm
corrplot::corrplot(cor(t(res_BPM[["U"]]))) # BPM
```


```{r}
### test SVM
library(e1071)
f1 <- svm(factor(dat[["Y"]]) ~ res_BPM[["U"]])
l1 <- predict(f1, res_BPM[["U"]])
sum(l1 == factor(dat[["Y"]]))
```

```{r}
save.image("./testcase.Rdata")
```


```{r}
load("./testcase.Rdata")
```
```{r}
dat2 <- document_generator_Normal(a, rho, Ts, Lambda, Tau, N, NULL, seed)
prediction3 <- SPM_predicting_Normal(dat2[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
sum(prediction3[["labels"]] == dat2[["Y"]])
```

```{r}
rho1=c(0.05, 0.05, 0.2462602, 0.2991388, 0.195597)
rho1 = rho1/sum(rho1)
dat2 <- document_generator_Normal(a, rho1, Ts, Lambda, Tau, N, NULL, seed)
prediction3 <- SPM_predicting_Normal(dat2[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
sum(prediction3[["labels"]] == dat2[["Y"]])
```


```{r}
for(p in seq(0.1, 0.9, by = 0.1)){
  set.seed(seed)
  rho1 <- c(rep(p/2, 2), rep((1 - p) / 3, 3))
  dat2 <- document_generator_Normal(a, rho1, Ts, Lambda, Tau, N, NULL, seed)
  prediction3 <- SPM_predicting_Normal(dat2[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
  print(p)
  print(sum(prediction3[["labels"]] == dat2[["Y"]]))
}
```


```{r}
rho1=c(0.05, 0.05, 0.2462602, 0.2991388, 0.195597)
rho1 = rho1/sum(rho1)
dat2 <- document_generator_Normal(a, rho1, Ts, Lambda, Tau, N, NULL, seed)
prediction3 <- SPM_predicting_Normal(dat2[["X"]], res[["Lambda"]], res[["Mu"]], res[["a"]], res[["rho"]], Ts, nsample, seed, w = NULL) # with results
sum(prediction3[["labels"]] == dat2[["Y"]])
```

```{r}
rhos <- gtools::rdirichlet(n = 1000, alpha = rep(1, 7))
t1 = rhos[,1] + rhos[, 2]
for(i in seq(0.1, 0.9, by = 0.1)){
  print(i)
  print(sum(t1<i))
}
```
```{r}
k0 = 2
k1 = 5
rhos <- gtools::rdirichlet(n = 1000, alpha = rep(1, 7))
t1 = rhos[,1] + rhos[, 2]
for(i in seq(0.1, 0.9, by = 0.1)){
  print(i)
  print(sum(t1<i))
}
```




### Vis
```{r}
dat$X %>% 
  as.data.frame() %>%
  mutate(label = factor(dat$Y),
         id = 1:dim(dat$X)[1]) %>%
  pivot_longer(cols = !c("label", "id"), names_to = "dimension", values_to = "coordinate") %>%
  arrange(coordinate) %>%
  ggplot(aes(x = dimension, y = coordinate, color = label, group = id)) +
  geom_line()
```

